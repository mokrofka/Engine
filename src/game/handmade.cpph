#include "lib.h"
#include "event.h"

struct Entity {
  union {
    struct {
      f32 x;
      f32 y;
      f32 width;
      f32 height;
    };

    Rect rect;
  };
  i32 tilemap_x;
  i32 tilemap_y;

  f32 vx, vy;
  u32 color;
};

struct TileMap {
  u32* tiles;
};

struct World {
  i32 tile_size_in_meters;
  i32 tile_side_in_pixels;

  i32 tiles_x_count;
  i32 tiles_y_count;

  i32 tilemaps_x_count;
  i32 tilemaps_y_count;

  f32 upper_left_x;
  f32 upper_left_y;

  TileMap* tilemaps;
};

struct GameState {
  Arena* arena;
  u32* pixels;
  i32 width;
  i32 height;
  Entity player;
  World world;
};

GameState* st;

////////////////////////////////////////////////////////////////////////
// Utils
v2i mouse_get_pos() {
  v2i win_size = os_get_window_size();
  f32 scale_x = (f32)st->width / win_size.x;
  f32 scale_y = (f32)st->height / win_size.y;

  v2i mouse_pos = os_get_mouse_pos();
  i32 buffer_x = (i32)(mouse_pos.x * scale_x);
  i32 buffer_y = (i32)(mouse_pos.y * scale_y);
  v2i pos = { buffer_x, buffer_y };
  return pos;
}

void window_pixels_map() {
  u32* win_buffer; Assign(win_buffer, os_window_get_buffer());
  v2i win_size = os_get_window_size();
  f32 scale_x = (f32)win_size.x / st->width;
  f32 scale_y = (f32)win_size.y / st->height;

  Loop (y , st->height) {
    Loop (x, st->width) {
      u32 color = st->pixels[y*st->width + x]; 
      Loop (dy, scale_y) {
        Loop (dx, scale_x) {
          i32 wx = x*scale_x + dx;
          i32 wy = y*scale_y + dy;
          win_buffer[wy*win_size.x + wx] = color;
        }
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////
// Drawing
void pixel_draw(v2u pos, u32 hex) {
  st->pixels[pos.y*st->width + pos.x] = hex;
}

void rect_draw(Rect rect, v3 rgb) {
  if (rect.x < 0) {
    rect.x = 0;
  }
  if(rect.y < 0) {
    rect.y = 0;
  }

  if(rect.width > st->width) {
    rect.width = st->width;
  }
  if(rect.height > st->height) {
    rect.height = st->height;
  }

  u32 hex = u32_from_argb(v3_to_v4(rgb, 1));

  Loop (y, rect.height) {
    Loop (x, rect.width) {
      pixel_draw(v2u(rect.x+x, rect.y+y), hex);
    }
  }
}

////////////////////////////////////////////////////////////////////////
// Tile Map

TileMap& get_tilemap(i32 tilemap_x, i32 tilemap_y) {
  TileMap* tilemap = null;

  if ((tilemap_x >= 0) && (tilemap_x < st->world.tiles_x_count) &&
      (tilemap_y >= 0) && (tilemap_y < st->world.tiles_y_count))
  {
    tilemap = &st->world.tilemaps[tilemap_y*st->world.tilemaps_x_count + tilemap_x];
  }
  Assert(tilemap);

  return *tilemap;
}

u32 get_tile_value_unchecked(TileMap tile_map, i32 tile_x, i32 tile_y) {
  i32 tiles_x = st->world.tiles_x_count;
  i32 tiles_y = st->world.tiles_y_count;
  Assert((tile_x >= 0) && (tile_x < tiles_x) &&
         (tile_y >= 0) && (tile_y < tiles_y));
  u32 tile_map_value = tile_map.tiles[tile_y*tiles_x + tile_x];
  return tile_map_value;
}

b32 is_tile_map_point_empty(TileMap tilemap, v2 test_tile) {
  b32 empty = false;
  if (test_tile.x >= 0 && test_tile.x < st->world.tiles_x_count &&
      test_tile.y >= 0 && test_tile.y < st->world.tiles_y_count) 
  {
    u32 tile_map_value = get_tile_value_unchecked(tilemap, test_tile.x, test_tile.y);
    empty = (tile_map_value == 0);
  }
  return empty;
}

// GetCanonicalPosition(world* World, raw_position Pos) {
//   canonical_position Result;

//   Result.TileMapX = Pos.TileMapX;
//   Result.TileMapY = Pos.TileMapY;

//   real32 X = Pos.X - World->UpperLeftX;
//   real32 Y = Pos.Y - World->UpperLeftY;
//   Result.TileX = FloorReal32ToInt32(X / World->TileSideInPixels);
//   Result.TileY = FloorReal32ToInt32(Y / World->TileSideInPixels);

//   Result.TileRelX = X - Result.TileX * World->TileSideInPixels;
//   Result.TileRelY = Y - Result.TileY * World->TileSideInPixels;

//   Assert(Result.TileRelX >= 0);
//   Assert(Result.TileRelY >= 0);
//   Assert(Result.TileRelX < World->TileSideInPixels);
//   Assert(Result.TileRelY < World->TileSideInPixels);

//   if (Result.TileX < 0) {
//     Result.TileX = World->CountX + Result.TileX;
//     --Result.TileMapX;
//   }

//   if (Result.TileY < 0) {
//     Result.TileY = World->CountY + Result.TileY;
//     --Result.TileMapY;
//   }

//   if (Result.TileX >= World->CountX) {
//     Result.TileX = Result.TileX - World->CountX;
//     ++Result.TileMapX;
//   }

//   if (Result.TileY >= World->CountY) {
//     Result.TileY = Result.TileY - World->CountY;
//     ++Result.TileMapY;
//   }

//   return (Result);
// }

b32 world_point_is_empty(TileMap tilemap, v2 test) {
  b32 empty;

  // empty = tile_map_is_empty_at_point(TileMap tilemap, v2 test_tile)
  // TileMap tilemap = get_tilemap()

}

void app_init(u8** state) {
  Assign(*state, mem_alloc_zero(sizeof(GameState)));
  Assign(st, *state);
  st->arena = arena_alloc();

  st->width = 200;
  st->height = 220;
  Assign(st->pixels, push_buffer(st->arena, st->width*4*st->height));

  event_register(EventCode_Resized, null, resize_callback);

  st->player = {
    .x = 30,
    .y = 30,
    .width = 10,
    .height = 10,
  };
}

shared_function void app_update(u8** state) {

  if (*state == null) {
    app_init(state);
  }
  Assign(st, *state);

  rect_draw({.width = (f32)st->width,.height = (f32)st->height}, v3(0.1));

  {
    f32 dx = 0, dy = 0;
    if (os_is_key_down(Key_W)) dy -= 1;
    if (os_is_key_down(Key_S)) dy += 1;
    if (os_is_key_down(Key_A)) dx -= 1;
    if (os_is_key_down(Key_D)) dx += 1;

    f32 len = Sqrt(Sqr(dx)+Sqr(dy));
    if (len > 0) {
      dx /= len;
      dx /= len;
    }

    f32 speed = 30;
    if (os_is_key_down(Key_LShift)) speed *= 4;
    
    f32 dplayer_x = dx * speed * delta_time;
    f32 dplayer_y = dy * speed * delta_time;

    Entity& player = st->player;
    // if (os_is_button_pressed(MouseButton_Left)) {
    if (os_is_button_down(MouseButton_Left)) {
      player.rect.min = v2(mouse_get_pos().x, mouse_get_pos().y);
    }

    f32 new_player_x = player.x + dplayer_x;
    f32 new_player_y = player.y + dplayer_y;

    player.x += dplayer_x;
    player.y += dplayer_y;

    st->player.width = 0.75*10;
    st->player.height = 10;
    rect_draw(st->player.rect, v3(1,0,0));
  }

#if 0
#define TILE_MAP_COUNT_X 17
#define TILE_MAP_COUNT_Y 9
  u32 tiles00[TILE_MAP_COUNT_Y][TILE_MAP_COUNT_X] = {
    {1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1, 1},
    {1, 1, 0, 0,  0, 1, 0, 0,  0, 0, 0, 0,  0, 1, 0, 0, 1},
    {1, 1, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 1, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 1, 0, 0,  1, 0, 0, 0,  0, 0, 0, 0, 0},
    {1, 1, 0, 0,  0, 1, 0, 0,  1, 0, 0, 0,  0, 1, 0, 0, 1},
    {1, 0, 0, 0,  0, 1, 0, 0,  1, 0, 0, 0,  1, 0, 0, 0, 1},
    {1, 1, 1, 1,  1, 0, 0, 0,  0, 0, 0, 0,  0, 1, 0, 0, 1},
    {1, 1, 1, 1,  1, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1, 1},
  };
  
  u32 tiles01[TILE_MAP_COUNT_Y][TILE_MAP_COUNT_X] = {
    {1, 1, 1, 1,  1, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 0},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1, 1},
  };
  
  u32 tiles10[TILE_MAP_COUNT_Y][TILE_MAP_COUNT_X] = {
    {1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 1, 1, 1,  1, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1, 1},
  };
  
  u32 tiles11[TILE_MAP_COUNT_Y][TILE_MAP_COUNT_X] = {
    {1, 1, 1, 1,  1, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0, 1},
    {1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1, 1},
  };

  TileMap tilemaps[2][2];
  tilemaps[0][0].tiles = (u32*)tiles00;
  tilemaps[0][1].tiles = (u32*)tiles01;
  tilemaps[1][0].tiles = (u32*)tiles10;
  tilemaps[1][1].tiles = (u32*)tiles11;

  st->world = {
    .tile_side_in_pixels = 10,
    .tiles_x_count = TILE_MAP_COUNT_X,
    .tiles_y_count = TILE_MAP_COUNT_Y,
    .tilemaps_x_count = 2,
    .tilemaps_y_count = 2,
    .upper_left_x = -(f32)st->world.tile_side_in_pixels/2,
    .upper_left_y = 0,
    .tilemaps = (TileMap*)tilemaps,
  };

  st->player.width = 0.75f*st->world.tile_side_in_pixels;
  st->player.height = st->world.tile_side_in_pixels;

  TileMap tilemap = get_tilemap(st->player.tilemap_x, st->player.tilemap_y);

  {
    f32 dx = 0, dy = 0;
    if (os_is_key_down(Key_W)) dy -= 1;
    if (os_is_key_down(Key_S)) dy += 1;
    if (os_is_key_down(Key_A)) dx -= 1;
    if (os_is_key_down(Key_D)) dx += 1;

    f32 len = Sqrt(Sqr(dx)+Sqr(dy));
    if (len > 0) {
      dx /= len;
      dx /= len;
    }

    f32 speed = 30;
    if (os_is_key_down(Key_LShift)) speed *= 4;
    
    f32 dplayer_x = dx * speed * delta_time;
    f32 dplayer_y = dy * speed * delta_time;

    Entity& player = st->player;
    if (os_is_button_pressed(MouseButton_Left)) {
      player.rect.min = v2(mouse_get_pos().x, mouse_get_pos().y);
    }

    f32 new_player_x = player.x + dplayer_x;
    f32 new_player_y = player.y + dplayer_y;

    f32 half_of_player_width = 0.5f*player.width;
    f32 half_of_player_height = 0.5f*player.height;
    v2 bottom_player = v2(new_player_x + player.width/2, new_player_y + player.height);
    if (is_tile_map_point_empty(tilemap, bottom_player) &&
        is_tile_map_point_empty(tilemap, {bottom_player.x - half_of_player_width, bottom_player.y}) &&
        is_tile_map_point_empty(tilemap, {bottom_player.x + half_of_player_width, bottom_player.y}))
    {
      player.x += dplayer_x;
      player.y += dplayer_y;
    }
  }

  {
    rect_draw({.width = (f32)st->width,.height = (f32)st->height}, v3(0.1));

    Loop (y, st->world.tiles_y_count) {
      Loop (x, st->world.tiles_x_count) {
        u32 tile_id = tilemap.tiles[y*st->world.tiles_x_count + x];
        f32 gray = 0.5;
        if (tile_id == 1) {
          gray = 0.2;
        }

        // f32 x_pos = x * st->world.tile_width;
        // f32 y_pos = y * st->world.tile_height;
        // rect_draw({x_pos,y_pos, (f32)st->world.tile_width,(f32)st->world.tile_height}, v3(gray));
      }
    }
    
    st->player.width = 0.75*10;
    st->player.height = 10;
    rect_draw(st->player.rect, v3(1,0,0));
  }
  #endif
  
  window_pixels_map();
}
