

////////////////////////////////////////////////////////////////////////
// Balls
Entity ball_create() {
  v2i mouse_pos = mouse_get_pos();
  f32 speed = rand_f32_01() /10;
  f32 angle = rand_f32_01() * Tau;

  Entity ball = {
    .rect = {
      .x = (f32)mouse_pos.x,
      .y = (f32)mouse_pos.y,
      .width = 5,
      .height = 5,
    },
    .vx = Cos(angle) * speed,
    .vy = Sin(angle) * speed,
    .color = u32_from_argb(v4(rand_f32_01(), rand_f32_01(), rand_f32_01(), rand_f32_01())),
  };

  return ball;
}

b32 box2d_is_collision(Rect a, Rect b) {
  b32 result = (a.x < b.x + b.width)  && (a.x + a.width > b.x) &&
               (a.y < b.y + b.height) && (a.y + a.height > b.y);
  return result;
}

void balls_update() {
  Loop (i, st->balls.count) {
    Entity& ball = st->balls[i];

    Loop (j, st->balls.count) {
      if (i == j) continue;
      Entity& ball_2 = st->balls[j];
      if (box2d_is_collision(ball.rect, ball_2.rect)) {
        if (Abs((ball.rect.x + ball.rect.width/2) - (ball_2.rect.x + ball_2.rect.width/2)) > Abs((ball.rect.y + ball.rect.y/2) - (ball_2.rect.y + ball_2.rect.y/2))) {
          ball.vx = -ball.vx;
        } else { // vertical collision
          ball.vy = -ball.vy;
        }
      }
    }

    if (ball.rect.x - 1 < 0 || ball.rect.x + ball.rect.width >= st->width) {
      ball.vx = -ball.vx;
    }
    if (ball.rect.y - 1 < 0 || ball.rect.y + ball.rect.height >= st->height) {
      ball.vy = -ball.vy;
    }

    ball.rect.x += ball.vx;
    ball.rect.y += ball.vy;

    rect_draw(ball.rect, ball.color);
  }
}
